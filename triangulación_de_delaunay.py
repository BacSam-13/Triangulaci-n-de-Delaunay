# -*- coding: utf-8 -*-
"""Triangulación de Delaunay.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/176SKGUDQKNjpMsZV8l3qz8HYUZb23iIP

# **Triangulación de Dalaunay**

Autor: Baruc Samuel Cabrera García

Una triángulación de un conjunto de puntos P, llamemosla T, es considerada de Delaunay si para todo triángulo, el círculo circunscrito de sus tres puntos no contiene a otro par de puntos.

O lo que es equivalente, todas las aristas son legales.

# Aristas ilegales

Sean p,q,s y p,q,r son triangulos adyacentes, con una arista cómun pq, tenemos que:

    pq es ilegal sii s \in int(D)

Donde D es el círculo circunscrito de los puntos p,q,r. (El resultado es igual si intercambiamos los papales de s con r)

En caso de que pq sea ilegal, realizamos la operación flip, lo que reemplaza a pq con rs.
Esto nos deja con los triangulos r,s,p y r,s,q.

# Librerías necesarias
"""

from collections import deque
import matplotlib.pyplot as plt
import math
import random
import queue
import numpy as np
import copy

pi = np.pi
inf = np.inf

"""# Funciones de apoyo 1"""

def orientation(p,q,r): # Nos dice en que lado esta r, según el segmento p -> q
  val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y)
  if val == 0:
    #print("En segmento")
    return 0
  elif val > 0:
    #print("Derecha")
    return 1
  else:
    #print("Izquierda")
    return -1


def get_circumcircle(a,b,c): # Obtiene el circulo circunstrito de los puntos a,b,c
  D = ( (a.x - c.x) * (b.y - c.y) - (b.x -  c.x) * (a.y - c.y) )

  if D == 0:
    return circle(Point(None, None), None)

  center_x = (((a.x - c.x) * (a.x + c.x) + (a.y - c.y) * (a.y + c.y)) / 2 * (b.y - c.y) - ((b.x - c.x) * (b.x + c.x) + (b.y - c.y) * (b.y +c.y)) / 2 * (a.y- c.y)) / D

  center_y = (((b.x - c.x) * (b.x + c.x) + (b.y - c.y) * (b.y + c.y)) / 2 * (a.x - c.x) - ((a.x - c.x) * (a.x + c.x) + (a.y - c.y) * (a.y + c.y)) / 2 * (b.x - c.x)) / D

  radius = math.sqrt ((c.x - center_x)**2 + (c.y - center_y)**2 )

  return circle(Point(center_x, center_y), radius)

def get_equilateral_triangle_vertices(circulo): # Crea un triangulo equilatero que contiene al circulo en cuestión
  c = circulo.c
  r = circulo.r
  vertices = [] # En orden antihorario
  for i in range(3):
    angle = (2*pi)*(i/3) # Dividmos los 2pi radianes en 3
    x = c.x + 2*r * math.cos(angle)
    y = c.y + 2*r * math.sin(angle)
    vertices.append(Point(x, y))

  return vertices

def do_intersect(s1, s2): # Determina si dos aristas, s1 y s2 se intersectan (No considera cuando comparten algún vertice)
  # Obtenemos los puntos de cada segmento
  p1, q1 = s1.origin, s1.end
  p2, q2 = s2.origin, s2.end

  if p1 == p2 or p1 == q2 or q1 == p2 or q1 == q2: # Si la interseccion es entre extremos, no la contamos, a menos que sean colinales
    if orientation(p1,q1,p2) == 0 and orientation(p1,q1,q2) == 0:
      return True
    return False

  # Recordemos que la intersección es solo válida si los dos segmentos se
  # intersectan en un solo punto que esta estrictamente dentro de ambos segmentos

  #Obtenemos las orientaciones de los puntos de cada segmento con el otro segmento
  o1 = orientation(p1, q1, p2)
  o2 = orientation(p1, q1, q2)
  o3 = orientation(p2, q2, p1)
  o4 = orientation(p2, q2, q1)

  # Ahora, consideraremos los siguientes casos para determinar si hay una interseccion

  # Si se cumple que ambos segmento forman una cruz
  if (o1 != o2 and o3 != o4):
    return True
  return False


# Funcion para obtener el punto de interseccion de dos segmentos
# Se asume que si se intersectan
def get_intersection(s1, s2):
  x1, y1 = s1.origin.x, s1.origin.y # Coordenadas de p1 de s1
  x2, y2 = s1.end.x, s1.end.y # Coordenadas de p2 de s1
  x3, y3 = s2.origin.x, s2.origin.y # Coordenadas de p1 de s2
  x4, y4 = s2.end.x, s2.end.y # Coordenadas de p2 de s2

  denom = ((x1 - x2) * (y3 - y4)) - ((y1 - y2) * (x3 - x4))

  # Encuentra el punto de intersección
  px = (((x1 * y2) - (y1 * x2)) * (x3 - x4) - (x1 - x2) * ((x3 * y4) - (y3 * x4))) / denom
  py = (((x1 * y2) - (y1 * x2)) * (y3 - y4) - (y1 - y2) * ((x3 * y4) - (y3 * x4))) / denom

  return Point(px, py)

"""# Clases de datos necesarias"""

# Puntos  (p esta encima de q <-> p < q) (El punto de menor valor sera el mas alto y mas a la derecha)
class Point:
  def __init__(self, x, y):
    self.x = x
    self.y = y

  def __add__(self, other): # Operacion suma
      return Point(self.x + other.x, self.y + other.y)

  def __sub__(self, other): # Operacion resta
      return Point(self.x - other.x, self.y - other.y)

  def print(self):
    print(f"({self.x}, {self.y})")

  def __lt__(self, other):
    if self.y == other.y:
      return self.x > other.x
    return self.y > other.y

  def __gt__(self, other):
    if self.y == other.y:
      return self.x < other.x
    return self.y < other.y

  def __eq__(self, other, dif = 0.001):
    return (self.x == other.x) and (self.y == other.y)


class circle:
  def __init__(self, c, r):
    self.c = c # centro del círculo (Point)
    self.r = r # radio del círculo

  def is_in(self, p): # Para determinar si un punto p esta dentro del circulo (no contamos la frontera)
    centro = self.c
    distancia = np.sqrt( (p.x - centro.x)**2 + (p.y - centro.y)**2 )

    return distancia < self.r

  def print(self):
    print(f"Centro: [{self.c.x}, {self.c.y}]")
    print(f"Radio: {self.r}")

class half_edge:
  def __init__(self,vi,vj):
    self.origin = vi
    self.twin = None
    self.next = None
    self.prev = None
    self.incident_face = None # Apunta a su cara incidente


  def __eq__(self, other):
    a1 = self.origin
    b1 = self.twin.origin

    a2 = other.origin
    b2 = other.twin.origin

    return a1 == a2 and b1 == b2


  def print(self):
    if self is None:
      print("None")
      return
    a = self.origin
    b = self.twin.origin
    #b = self.end
    print(f"({a.x},{a.y}) ----> ({b.x},{b.y})")

  def oposite(self): # Si la arista forma parte de un triangulo, regresamos el vertice que no esta en la arista
    return self.prev.origin

class triangle: # Funjen como caras
  def __init__(self, hedges): # Se recibe un conjunto de aristas conectadas que unnen a puntos abc
    for edge in hedges:
      edge.incident_face = self

    self.wedge = hedges[0] # hedge asociada

  def get_hedges(self): # Obtenemos las aristas en sentido antihorario (se supone que ya estan en tal orden)
    Hedges = []
    aux = self.wedge
    Hedges.append(aux)

    origen = aux.origin
    aux = aux.next
    count = 1
    while aux.origin != origen and count <= 3:
      Hedges.append(aux)
      aux = aux.next
      count += 1

    if count > 3: # Si hay mas de 3 aristas, hay un error
      print("XXXXXXXXXXXXXXXXXXXX     ERROR     XXXXXXXXXXXXXXXXXXXX")

    return Hedges

  def get_points(self): # Analoga a get_hedges
    #print("Se llamo a get_points")
    Hedges = self.get_hedges()
    P = []
    for h in Hedges:
      #h.origin.print()
      P.append(h.origin)
    #print("Termino get_points\n")
    P.sort() # Ordenamos los puntos antes de sacarlos, sirve para comparar triangulos
    return P

  def is_contain(self, p): # Determinamos si p esta contenido dentro de T
    Hedges = self.get_hedges()
    Flag_inside = True
    Flag_hedge = False

    # Exploramos las aristas, para usar orientation() y determinar el estado de p
    for he in Hedges:
      a = he.origin
      b = he.twin.origin
      if orientation(a,b,p) == 1: # Si ya esta fuera del triangulo
        Flag_inside = False
        break
      if orientation(a,b,p) == 0: # Si es colineal a alguna arista
        Flag_hedge = True

    if Flag_inside and Flag_hedge: # Si p es colineal a una hedge y esta dentro del triangulo
      return True, 1 # p esta en una arista de T
    elif Flag_inside and not Flag_hedge: # Si no es colineal a una hedge y esta dentro del triangulo
      return True, 0 # p esta en el interior de T
    return False, -1

  def __eq__(self, other): # Dos triangulos son iguales si comparten sus tres vertices
    P1 = self.get_points()
    P2 = other.get_points()

    for i in range(len(P1)):
      if P1[i] != P2[i]:
        return False
    return True

  def print(self):
    Hedges = self.get_hedges()
    for he in Hedges:
      he.print()

"""# Funciones de apoyo 2"""

# Queremos hacer flip con la arista e_ab / e_ba
def flip(e_pq, T): # Funcion que hace flip con la arista pq y sus triangulos asociados

  # Obtenemos los triangulos de e_pq (superior e inferior)
  t1 = e_pq.incident_face # pqs
  t2 = e_pq.twin.incident_face #qpr

  # Obtenemos el resto de aristas
  e_qs = e_pq.next
  e_sp = e_pq.prev

  e_pr = e_pq.twin.next
  e_rq = e_pq.twin.prev

  # Creamos la nueva dupla de half edges
  s = e_pq.oposite()
  r = e_pq.twin.oposite()

  # Modificamos e_pq y e_pq.twin segun los nuevos triangulos
  e_pq.origin = r
  e_pq.twin.origin = s

  e_pq.next = e_sp
  e_pq.prev = e_pr

  e_pq.twin.next = e_rq
  e_pq.twin.prev = e_qs

  # Modificamos las aristas ya existentes
  e_sp.next = e_pr
  e_sp.prev = e_pq

  e_pr.next = e_pq
  e_pr.prev = e_sp


  e_rq.next = e_qs
  e_rq.prev = e_pq.twin

  e_qs.next = e_pq.twin
  e_qs.prev = e_rq

  # Reasignamos los triangulos
  T.remove(t1)
  T.remove(t2)

  T.append(triangle([e_pq, e_sp, e_pr]))
  T.append(triangle([e_pq.twin, e_rq, e_qs]))

  """print("SE REALIZO FLIP, LOS TRIANGULOS RESULTANTES SON:")
  t1.print()
  print("\n")
  t2.print()
  print("\n")"""

def is_flip_posible(e): # Considerando los triangulos de la arista e, se verifica que la figura resultante sea convexa para que el flipear sea posible (Para el caso 3 de legalize_edge)

  i = e.origin
  j = e.twin.origin

  l = e.oposite()
  k = e.twin.oposite()

  if orientation(k,j,l) == -1 and orientation(k,i,l) == 1:
    return True
  return False


def create_half_edge(a,b): # Creamos dos half edges que unen ab
  e_ab = half_edge(a,b)
  e_ba = half_edge(b,a)

  e_ab.twin = e_ba
  e_ba.twin = e_ab

  return e_ab, e_ba

def bond_half_edges(e1,e2,e3): # Actualizamos .next y .prev segun el orden e1,e2,e3
  e1.next = e2
  e1.prev = e3

  e2.next = e3
  e2.prev = e1

  e3.next = e1
  e3.prev = e2

def create_3_hedges(A,B,C): # Crearemos 3 half_edges (ab, bc, ca) con sus respectivos twins

  # Generamos las half edges necesarias, así como ajustar sus twin
  e_ab, e_ba = create_half_edge(A,B)

  e_bc, e_cb = create_half_edge(B,C)

  e_ca, e_ac = create_half_edge(C,A)

  # Preparamos las half edges con sus next y prev
  bond_half_edges(e_ab,e_bc,e_ca)

  # Regresamos dos arreglos, uno para cada orden (orden original e inverso)
  return [e_ab,e_bc,e_ca], [e_ba, e_ac, e_cb]


def print_T(T):
  print(f"\nHay {len(T)} triangulos hasta el momento")
  print("xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx")
  for i in range(len(T)):
    print(f"Triangulo {i}:")
    T[i].print()
    print("\n")
  print("xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n")

def get_coords_circle(circle): # Obtenemos np.linspace para graficar un circulo
  theta = np.linspace(0, 2 * np.pi, 100)

  # Calcular las coordenadas x e y del círculo
  x = circle.c.x + circle.r * np.cos(theta)
  y = circle.c.y + circle.r * np.sin(theta)

  return x,y

"""# Algoritmo de Triangulación de Delaunay"""

def Delaunay_Triangulation(P, epsilon = 1):

  # Primero, buscaremos un triangulo que contenga a todo P
  # Para esto, buscaremos encerrar a P en un rectangulo usando sus coordenadas maximas
  # Luego, usando tres vertices, crearemos un circulo que pase por esos 3 vertices
  # Expandiremos un poco ese circulo al extender el rectangulo para asi generar un triangulo que tenga al circulo circunscrito
  # Este sera nuestro triangulo

  min_x = inf
  min_y = inf
  max_x = -inf
  max_y = -inf

  for p in P: # Obtenemos las coordenadas maximas
    if p.x < min_x:
      min_x = p.x
    if p.x > max_x:
      max_x = p.x
    if p.y < min_y:
      min_y = p.y
    if p.y > max_y:
      max_y = p.y

  # Construimos el triangulo Omega
  A = Point(min_x - epsilon, min_y - epsilon)
  B = Point(max_x + epsilon, min_y - epsilon)
  C = Point(max_x + epsilon, max_y + epsilon)

  circulo = get_circumcircle(A,B,C)
  p__1, p__2, p__3 = get_equilateral_triangle_vertices(circulo)


  T = []
  # Inicializamos a T con el triangulo p__1,p__2,p__3
  hedges, hedges_twin = create_3_hedges(p__1,p__2,p__3)
  t_omega = triangle(hedges)
  T.append(t_omega)
  """plot_Faces(P, Faces = T, p__1 = p__1, p__2 = p__2, p__3 = p__3)
  print("El triangulo Omega es:")
  t_omega.print()
  print("\n")"""

  # Generamos una permutacion aleatoria de P
  random.shuffle(P) # Aleatorizamos

  n = len(P)
  for r in range(n):
    pr = P[r]
    t, where = search_t(T,pr) # buscamos un triangulo que contenga  pr
    """print("°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°\n")
    print("Analizamos el punto:")
    pr.print()
    print("\nEsta contenido en el triangulo:")
    t.print()
    print("\n")"""

    if where == 0: # Si pr esta dentro de t
      #print("Esta en su interior\n")
      E_t = t.get_hedges() # Obtenemos las aristas originales de t
      # Dividimos a t en tres triangulos (sus aristas originales se mantienen, pero en los 3 triangulos)
      create_triangle_inside(T, pr, t)
      #plot_Faces(P, Faces = T,   p__1 = p__1, p__2 = p__2, p__3 = p__3, p_focus = pr)
      #print_T(T)
      for e in E_t:
        legalize_edge(pr, e, T, P, p__1,p__2,p__3)

    else: # p se encuentra en una arista de t
      print("Esta en una arista\n")
      E_t = t.get_hedges()

      for he in E_t: # Buscamos la arista e donde se encuentra p
        if orientation(he.origin, he.twin.origin, pr) == 0:
          e = he
          break

      # Tomamos las aristas que debemos legalizar (el orden es irrelevante)
      e_1 = e.next
      e_2 = e.prev
      e_3 = e.twin.next
      e_4 = e.twin.prev

      create_triangle_edge(T, pr, e, e.incident_face, e.twin.incident_face) # Creamos los triangulos segun el caso
      #plot_Faces(P, Faces = T,  A = A, B  = B, C = C)
      print_T(T)
      # Legalizamos las aristas
      legalize_edge(pr, e_1, T, P, p__1,p__2,p__3)
      legalize_edge(pr, e_2, T, P, p__1,p__2,p__3)
      legalize_edge(pr, e_3, T, P, p__1,p__2,p__3)
      legalize_edge(pr, e_4, T, P, p__1,p__2,p__3)

  T_new = []
  # Eliminamos los triangulos externos, i.e, los que tengan alguno de los vertices p__1, p__2, p__3

  for t in T:
    Points_t = t.get_points()
    if p__1 in Points_t:
      continue
    elif p__2 in Points_t:
      continue
    elif p__3 in Points_t:
      continue
    else:
      #print("El triangulo no tiene a p__1, p__2, p__3")
      T_new.append(t)

  #print("Triangulos finales")
  #print_T(T)

  return T_new

def search_t(T, p): # En el conjunto T, buscamos un triangulo que contenga a p
  for t in T:
    flag, where = t.is_contain(p)
    if flag:
      return t, where

  print("FAIL") # Si no se encontro un triangulo que contenga a p (Error)
  plot_Faces([p], Faces = T)
  print_T(T)

def create_triangle_inside(T, p, t0): # Dado un triangulo t0, los reemplazaremos con otros tres triangulos en su interior
  # Extraemos las aristas para generar los triangulo
  E = t0.get_hedges()

  # Obtenemos las aristas y vertices del triangulo t0
  e1 = E[0]
  v1 = e1.origin
  e2 = E[1]
  v2 = e2.origin
  e3 = E[2]
  v3 = e3.origin

  # Debemos generar 2 halfedges para cada nuevo triangulo, tambien ajustamos sus twins
  e_1p, e_p1 = create_half_edge(v1,p)

  e_2p, e_p2 = create_half_edge(v2,p)

  e_3p, e_p3 = create_half_edge(v3,p)


  # Preparamos el triangulo t1 (v1,v2,p)
  bond_half_edges(e1, e_2p, e_p1)

  t1 = triangle([e1, e_2p, e_p1])

  # Preparamos el triangulo t2 (v2,v3,p)
  bond_half_edges(e2, e_3p, e_p2)

  t2 = triangle([e2, e_3p, e_p2])

  # Preparamos el triangulo t3 (v3,v1,p)
  bond_half_edges(e3, e_1p, e_p3)

  t3 = triangle([e3, e_1p, e_p3])

  # Removemos a t0
  T.remove(t0)
  # Agregamos a t1, t2, t3
  T.append(t1)
  T.append(t2)
  T.append(t3)

def create_triangle_edge(T, p, e): # Dada una arista e y un punto p en ella, se buscan reemplazar los triangulos de e y e.twin con dos mas, usando a p
  # Los triangulos originales a dividir
  t_01 = e.incident_face
  t_02 = e.twin.incident_face

  #Imaginaremos que e es horizontal, tal que t_01 es el triangulo superior y t_02 es el triangulo inferior

  # Extremo de e segun t_01
  k_top = e.oposite()
  # Extremo de e segun t_02
  k_low = e.twin.oposite()

  # Creamos las nuevas half edges que dividen a los triangulos
  e_p_kt, e_kt_p = create_half_edge(p, k_top)

  e_p_kl, e_kl_p = create_half_edge(p, k_low)

  # Dividimos a e y e.twin
  v1 = e.origin # t_01 seria v1,v2,k_top
  v2 = e.twin.origin # t_02 seria v2,v1,k_low

  e_v1_p, e_p_v1 = create_half_edge(v1, p)
  bond_half_edges(e_v1_p, e_p_kt, e.prev) # Triangulo izquierdo superior
  bond_half_edges(e_p_v1, e.twin.next, e_kl_p) # Triangulo izquierdo inferior


  e_v2_p, e_p_v2 = create_half_edge(v2, p)
  bond_half_edges(e_p_v2, e.next, e_kt_p) # Triangulo derecho superior
  bond_half_edges(e_v2_p, e_p_kl, e.twin.prev) # Triangulo derecho inferior

  # Creamos los nuevos triangulos
  t1 = triangle([e_p_kt, e.prev, e_v1_p])

  t2 = triangle([e_kt_p, e_p_v2, e.next])

  t3 = triangle([e_p_kl, e.twin.prev, e_v2_p])

  t4 = triangle([e_kl_p, e_p_v1, e.twin.next])


  # Removemos t_01 y t_02
  T.remove(t_01)
  T.remove(t_02)

  # Agregamos a t1, t2, t3, t4
  T.append(t1)
  T.append(t2)
  T.append(t3)
  T.append(t4)


def legalize_edge(p, e, T, P, p__1, p__2, p__3): # El punto insertado es p, y la arista que puede ser flipeada es pr

  Omega_points = [p__1, p__2, p__3]

  #print("Legalizaremos la arista")
  #e.print()

  if e.twin.incident_face is None: # No se puede legalizar, porque e es un extremo [Caso 1]
    #print("La arista es un borde\n")
    return

  # El punto siendo insertado es p, y e es la arista de T que puede ser flipeada (p pertenece al triangulo formado por la half edge e)

  # ij es la arista que puede ser flipeada, rp es la que lo reemplazaria
  r = e.twin.oposite()
  i = e.origin
  j = e.twin.origin

  if not((i in Omega_points) or (j in Omega_points) or (p in Omega_points) or (r in Omega_points)): # Si no hay nngun punto omega involucrado [Caso 2]
    circulo_ep = get_circumcircle(p, e.origin, e.twin.origin)
    if not circulo_ep.is_in(r): # Si r no esta dentro del circulo e,p [Caso 2]
      #print("La arista es legal (fuera de circulo [Caso 2]) \n")
      return # es legal y no se hace nada
    else:
      #print("La arista es ilegal (Caso 2)\n")
      # Obtenemos las aristas que se deben revisar luego de hacer flip con e
      e_1 = e.twin.next
      e_2 = e.twin.prev
      flip(e,T)
      #plot_Faces(P, p__1 = p__1, p__2 = p__2, p__3 = p__3, Faces = T, p_focus = p)
      #print_T(T)
      legalize_edge(p, e_1, T, P, p__1,p__2,p__3)
      legalize_edge(p, e_2, T, P, p__1,p__2,p__3)

  else: # [Caso 3]


    if (r in Omega_points) and not(i in Omega_points or j in Omega_points): #Si solo r es un punto Omega
      #print("La arista es legal (La arista no tiene puntos Omega, pero el opuesto si lo es)\n")
      return

    elif not(r in Omega_points) and (i in Omega_points or j in Omega_points): # Si r no es punto Omega, pero alguno de i,j si
      if is_flip_posible(e): # Si el flip es posible
        #print("La arista es ilegal (Caso 3. e tiene un punto Omega y el flip es posible)\n")
        # Obtenemos las aristas que se deben revisar luego de hacer flip con e
        e_1 = e.twin.next
        e_2 = e.twin.prev
        flip(e,T)
        #plot_Faces(P, p__1 = p__1, p__2 = p__2, p__3 = p__3, Faces = T, p_focus = p)
        #print_T(T)
        legalize_edge(p, e_1, T, P, p__1,p__2,p__3)
        legalize_edge(p, e_2, T, P, p__1,p__2,p__3)

    else:
      circulo_ep = get_circumcircle(p, e.origin, e.twin.origin)
      if not circulo_ep.is_in(r): # Si r no esta dentro del circulo e,p [Caso 2]
        #print("La arista es legal (fuera de circulo [Caso 3]) \n")
        return # es legal y no se hace nada
      else:
        #print("La arista es ilegal (Caso 3. Criterio de circulo)\n")
        # Obtenemos las aristas que se deben revisar luego de hacer flip con e
        e_1 = e.twin.next
        e_2 = e.twin.prev
        flip(e,T)
        #plot_Faces(P, p__1 = p__1, p__2 = p__2, p__3 = p__3, Faces = T, p_focus = p)
        #print_T(T)
        legalize_edge(p, e_1, T, P, p__1,p__2,p__3)
        legalize_edge(p, e_2, T, P, p__1,p__2,p__3)

"""# Funciones para visualizacion y generacion de muestras"""

def plot_Faces(Vertices, p__1 = None, p__2 = None, p__3 = None, Faces = None, p_focus = None, Circulos = True):
  plt.figure(figsize=(8, 8))

  Omega = [p__1, p__2, p__3] # Los puntos omega son los puntos del triangulo exterior

  for v in Vertices: # Graficamos todos los vertices
    plt.scatter(v.x, v.y, color= 'blue', s=50, edgecolors='black')

  if Faces is not None: # En caso de mandar una triangulacion

    for f in Faces: # Exploramos todas las caras
      puntos_f = f.get_points()
      if Circulos: # Si queremos graficar los circulos

        if p_focus is None: # Si no queremos graficar solo los circulos de un punto
          circulo_F = get_circumcircle(puntos_f[0],puntos_f[1],puntos_f[2])
          x,y = get_coords_circle(circulo_F)
          plt.plot(x, y,linestyle = '--')
        else:
          if p_focus in puntos_f and not(p_focus in Omega): # Si p_focus esta en el triangulo actual, graficamos el circulo de tal triangulo
            circulo_F = get_circumcircle(puntos_f[0],puntos_f[1],puntos_f[2])
            x,y = get_coords_circle(circulo_F)
            plt.plot(x, y,linestyle = '--')

      Hedges = f.get_hedges() # Obtenemos las aristas de la cara
      if p__1 is not None:
        if (puntos_f[0] in Omega) or (puntos_f[1] in Omega) or (puntos_f[2] in Omega): # Si el triangulo a graficar tiene algun punto Omega
          for edge in Hedges: # Graficaremos cada arista, asi como su punto origen con su color (arista a -> b con color c)
            a = edge.origin
            b = edge.twin.origin
            plt.plot([a.x, b.x], [a.y, b.y], color = 'gray')
        else:
          for edge in Hedges: # Graficaremos cada arista, asi como su punto origen con su color (arista a -> b con color c)
            a = edge.origin
            b = edge.twin.origin
            plt.plot([a.x, b.x], [a.y, b.y],color='black')
      else:
           for edge in Hedges: # Graficaremos cada arista, asi como su punto origen con su color (arista a -> b con color c)
            a = edge.origin
            b = edge.twin.origin
            plt.plot([a.x, b.x], [a.y, b.y],color='black')

  if p__1 is not None: # En caso de incluir a los puntos Omega, delimitamos los margenes del plot
    plt.xlim(p__2.x - 1, p__1.x + 1)
    plt.ylim(p__3.y - 1, p__2.y + 1)


  plt.xlabel('X')
  plt.ylabel('Y')
  plt.title('Triangulacion')
  plt.grid(True)
  #plt.axis('equal')
  plt.gca().set_aspect('equal', adjustable='box')
  plt.show()

def generate_sample(n, x_lim, y_lim): # Generamos n puntos en [x_lim[0], x_lim[1]] x [y_lim[0], y_lim[1]]
  P = []

  for i in range(n):
    x = random.uniform(x_lim[0], x_lim[1])
    y = random.uniform(y_lim[0], y_lim[1])
    P.append(Point(x,y))
  return P

"""# Ejecucion del codigo"""

n = 7
x_lim = [0,10]
y_lim = [0,10]

V = generate_sample(n, x_lim, y_lim)
plot_Faces(V)
print("Los puntos que se usaran son los siguientes:")
for v in V:
  v.print()

T = Delaunay_Triangulation(V)

print("RESULTADO FINAL SIN PUNTOS OMEGA")
plot_Faces(V, Faces = T, Circulos = False)
#plot_Faces(P, p__1 = p__1, p__2 = p__2, p__3 = p__3, Faces = T, p_focus = p)